  .SECTION .DATA

  ########## CONSTANTS ########## 

  #SYSCALL NUMBERS
  .EQU SYS_OPEN, 5
  .EQU SYS_WRITE, 4
  .EQU SYS_READ, 3
  .EQU SYS_CLOSE, 6
  .EQU SYS_EXIT, 1

  #OPTIONS FOR OPENING FILES
  .EQU O_RDONLY, 0
  .EQU O_CREAT_WRONGLY_TRUNC, 03101

  #STANDARD FILE DESCRIPTORS
  .EQU STDIN, 0
  .EQU STDOUT, 1
  .EQU STDERR, 2

  #SYSCALL INTERRUPT
  .EQU LINUX_SYSCALL, 0X80

  .EQU EOF, 0     #THIS IS THE RETURN VALUE OF READ, WHICH MEANS WE'VE HIT THE END OF FILE
  .EQU NUM_ARGS, 2

  .SECTION .BSS
    .EQU BUFFER_SIZE, 500
    .LCOMM BUFFER_DATA, BUFFER_SIZE

  .SECTION .TEXT

  #STACK POSITIONS
  .EQU ST_SIZE_RESERVE, 8
  .EQU ST_FD_IN, -4
  .EQU ST_FD_OUT, -8
  .EQU ST_ARGC, 0       #NUMBER OF ARGUMENTS
  .EQU ST_ARGV_0, 4     #NAME OF THE PROGRAM
  .EQU ST_ARGV_1, 8     #INPUT FILE NAME
  .EQU ST_ARGV_2, 12    #OUTPUT FILE NAME

  .GLOBL _START
_START:
  ### INITIALIZE THE PROGRAM ###
  # SAVE THE STACK POINTER
  MOVL %ESP, %EBP

  #ALLOCATE SPACE FOR FILE DESCRIPTORS ON THE STACK
  SUBL $ST_SIZE_RESERVE, %ESP

OPEN_FILES:
OPEN_FD_IN:
  ## OPEN INPUT FILE ##
  # OPEN SYSCALL
  MOVL $SYS_OPEN, %EAX
  # INPUT FILE NAME FIRST CHAR ADDRESS INTO %EBX
  MOVL ST_ARGV_1(%EBP), %EBX
  # READ ONLY FLAG
  MOVL $O_RDONLY, %ECX
  MOVL $0666, %EDX      #NOT REALLY NECESSARY FOR READING
  INT $LINUX_SYSCALL

STORE_FD_IN:
  # SAVE THE GIVEN FILE DESCRIPTOR
  MOVL %EAX, ST_FD_IN(%EBP)

OPEN_FD_OUT:
  ## OPEN OUTPUT FILE ##
  # OPEN THE FILE
  MOVL $SYS_OPEN, %EAX
  # OUTPUT FILENAME INTO %EBX
  MOVL ST_ARGV_2(%EBP), %EBX
  # FLAGS FOR WRITING TO THE FILE
  MOVL $O_CREAT_WRONGLY_TRUNC, %ECX
  # MODE FOR NEW FILE (IF IT'S CREATED)
  MOVL $0666, %EDX
  INT $LINUX_SYSCALL

STORE_FD_OUT:
  # SAVE THE OUTPUT FILE DESCRIPTOR
  MOVL %EAX, ST_FD_OUT(%EBP)

  ### BEGIN MAIN LOOP ###
READ_LOOP_BEGIN:

  ### READ IN A BLOCK FROM THE INPUT FILE ###
  MOVL $SYS_READ, %EAX
  # GET THE INPUT FILE DESCRIPTOR
  MOVL ST_FD_IN(%EBP), %EBX
  # THE LOCATION TO READ INTO
  MOVL $BUFFER_DATA, %ECX
  # THE SIZE OF THE BUFFER
  MOVL $BUFFER_SIZE, %EDX
  INT $LINUX_SYSCALL

  ### EXIT IF WE'VE REACHED EOF ###
  # CHECK FOR END OF FILE MARKER
  CMPL $EOF, %EAX   # AS SIZE OF BUFFER READ IS RETURNED IN %EAX
  # IF FOUND, OR ON ERROR, GO TO THE END
  JLE END_LOOP

CONTINUE_READ_LOOP:
  ### CONVERT BLOCK TO UPPER CASE ###
  PUSHL $BUFFER_DATA      # LOCATION OF THE BUFFER
  PUSHL %EAX              # SIZE OF THE BUFFER
  CALL CONVERT_TO_UPPER

  POPL %EAX               # GET THE SIZE BACK
  ADDL $4, %ESP           # RESTORE %ESP

  ### WRITE THE BLOCK OUT TO THE OUTPUT FILE ###
  # SIZE OF THE BUFFER
  MOVL %EAX, %EDX
  MOVL $SYS_WRITE, %EAX
  # FILE TO USE
  MOVL ST_FD_OUT(%EBP), %EBX
  # LOCATION OF THE BUFFER
  MOVL $BUFFER_DATA, %ECX
  INT $LINUX_SYSCALL

  ### CONTINUE THE LOOP ###
  JMP READ_LOOP_BEGIN

END_LOOP:
  ### CLOSE THE FILES ###
  # NO ERROR CHECKING, BECAUSE ERROR CONDITIONS DO NOT SIGNIFY ANYTHING SPECIAL HERE
  MOVL $SYS_CLOSE, %EAX
  MOVL ST_FD_OUT(%EBP), %EBX
  INT $LINUX_SYSCALL

  MOVL $SYS_CLOSE, %EAX
  MOVL ST_FD_IN(%EBP), %EBX
  INT $LINUX_SYSCALL

  ### EXIT ###
  MOVL $SYS_EXIT, %EAX
  MOVL $0, %EBX
  INT $LINUX_SYSCALL

  .EQU LOWERCASE_A, 'A'   # THE LOWER BOUNDARY OF OUR SEARCH
  .EQU LOWERCASE_Z, 'Z'   # THE UPPER BOUNDARY OF OUR SEARCH
  .EQU UPPER_CONVERSION, 'A' - 'A'

  ### STACK STUFF ###
  .EQU ST_BUFFER_LEN, 8
  .EQU ST_BUFFER, 12

CONVERT_TO_UPPER:
  ### FUNCTION PROLOGUE ###
  PUSHL %EBP
  MOVL %ESP, %EBP

  ### SETTING UP VARS ###
  MOVL ST_BUFFER(%EBP), %EAX
  MOVL ST_BUFFER_LEN(%EBP), %EBX
  MOVL $0, %EDI

  # IF BUFFER LENGTH == 0, JUST EXIT
  CMPL $0, %EBX
  JE END_CONVERT_LOOP

CONVERT_LOOP:
  # GET THE CURRENT BYTE
  MOVB (%EAX,%EDI,1), %CL

  # GO TO NEXT BYTE UNLESS IT IS BETWEEN 'A' AND 'Z'
  CMPB $LOWERCASE_A, %CL
  JL NEXT_BYTE
  CMPB $LOWERCASE_Z, %CL
  JG NEXT_BYTE

  # OTHERWISE CONVERT THE BYTE TO UPPERCASE 
  ADDB $UPPER_CONVERSION, %CL
  MOVB %CL, (%EAX,%EDI,1)

NEXT_BYTE:
  INCL %EDI
  CMPL %EDI, %EBX
  JNE CONVERT_LOOP

END_CONVERT_LOOP:
  ### FUNCTION EPILOGUE ###
  MOVL %EBP, %ESP
  POPL %EBP
  RET
